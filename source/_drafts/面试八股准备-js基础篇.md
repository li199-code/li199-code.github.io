---
title: 面试八股准备-js基础篇
date: 2022-08-09 17:45:28
tags: 
- javascript
- interview
---

#### 说说JavaScript中的数据类型？存储上的差别？

在JavaScript中，我们可以分成两种类型：基本类型,引用类型
两种类型的区别是：存储位置不同。

基本数据类型：
Number
String
Boolean
Undefined
null

引用数据类型：
Object
Array
Function

<!--more-->

- 声明变量时不同的内存地址分配：

简单类型的值存放在栈中，在栈中存放的是对应的值。
引用类型对应的值存储在堆中，在栈中存放的是指向堆内存的地址
- 不同的类型数据导致赋值变量时的不同：

简单类型赋值，是生成相同的值，两个对象对应不同的地址
复杂类型赋值，是将保存对象的内存地址赋值给另一个变量。也就是两个变量指向堆内存中同一个对象

#### 栈和堆的区别
- 空间：栈小，堆大
- 访问方式：栈直接访问，堆需要指针
- 生命周期：栈内存和函数调用的生命周期一致，而堆可能一致存在，故需要额外的垃圾回收机制

#### 谈谈 JavaScript 中的类型转换机制

- 显式转换

Number()
parseInt()
String()
Boolean()

- 隐式转换

可分为两种场景：1.比较运算，需要布尔值；2.算术运算。

比较运算：除了undefined\null\0等会转换为false,其他的转为true
加号+：转换为字符串
除了加号的运算符：转换为number


#### == 和 ===区别，分别在什么情况使用

- 等于操作符

两个都为简单类型，字符串和布尔值都会转换成数值，再比较

简单类型与引用类型比较，对象转化成其原始类型的值，再比较

两个都为引用类型，则比较它们是否指向同一个对象

null 和 undefined 相等

存在 NaN 则返回 false

- 全等操作符

在类型和值都相同时，才返回true

- 区别

相等操作符（==）会做类型转换，再进行值的比较，全等运算符不会做类型转换

null 和 undefined 比较，相等操作符（==）为true，全等为false

- 使用

为了不引起歧义，一般都用全等

### 深拷贝和浅拷贝的区别

1. 浅拷贝：只复制引用，而未复制真正的值。

		var obj2=Object.assign(obj1)
		
2. 深拷贝：是复制真正的值 （不同引用）

		//递归的形式
		function copyObj( obj ){
			if(  Array.isArray(obj)  ){
				var newObj = [];
			}else{
				var newObj = {};
			}
			for( var key in obj ){
				if( typeof obj[key] == 'object' ){
					newObj[key] = copyObj(obj[key]);
				}else{
					newObj[key] = obj[key];
				}
			}
			return newObj;
		}

#### 闭包的理解

闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。
闭包有两个常用的用途；

闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量。
闭包的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。

缺点：因为闭包在处理速度和内存消耗方面对脚本性能具有负面影响，所以应该尽量避免使用闭包。

#### 作用域链的理解

- 作用域

作用域，即变量（变量作用域又称上下文）和函数生效（能被访问）的区域或集合

一般分为三种：全局作用域，函数作用域，块级作用域

- 作用域链

当在Javascript中使用一个变量的时候，首先Javascript引擎会尝试在当前作用域下去寻找该变量，如果没找到，再到它的上层作用域寻找，以此类推直到找到该变量或是已经到了全局作用域

如果在全局作用域里仍然找不到该变量，它就会在全局范围内隐式声明该变量(非严格模式下)或是直接报错

#### 原型和原型链

原型是什么：对象的构造函数的一个特殊属性，对象可以从原型中继承属性和方法
1. 原型可以解决什么问题
	对象共享属性和共享方法
2. 谁有原型
函数拥有：prototype
对象拥有：\__proto__
3. 对象查找属性或者方法的顺序
	先在对象本身查找 --> 构造函数中查找 --> 对象的原型 --> 当前原型的原型中查找
4. 原型链
	4.1 是什么？：就是把原型串联起来
	4.2 原型链的最顶端是null

#### 继承

##### 方式一：ES6

```
class Parent{
	constructor(){
		this.age = 18;
	}
}

class Child extends Parent{
	constructor(){
		super();
		this.name = '张三';
	}
}
let o1 = new Child();
console.log( o1,o1.name,o1.age );
```

##### 方式二：原型链继承

```
function Parent(){
	this.age = 20;
}
function Child(){
	this.name = '张三'
}
Child.prototype = new Parent();
let o2 = new Child();
console.log( o2,o2.name,o2.age );
```

##### 方式三：借用构造函数继承

```
function Parent(){
	this.age = 22;
}
function Child(){
	this.name = '张三'
	Parent.call(this);
}
let o3 = new Child();
console.log( o3,o3.name,o3.age );
```

##### 方式四：组合式继承

```
function Parent(){
	this.age = 100;
}
function Child(){
	Parent.call(this);
	this.name = '张三'
}
Child.prototype = new Parent();
let o4 = new Child();
console.log( o4,o4.name,o4.age );
```

#### this指向

this总是动态指向实际执行函数的对象，而不是代码位置。

1. 默认绑定：全局环境中执行函数，this指向window

2. 隐式绑定：当this所在函数作为对象方法时被调用时，this指向这个对象

3. 构造函数绑定：通过构建函数new关键字生成一个实例对象，此时this指向这个实例对象

	特殊情况：构造函数return一个对象时，this指向这个return对象

4. 显式绑定
apply()、call()、bind()是函数的一个方法，作用是改变函数的调用对象。

#### 事件流和事件模型

事件是用户和浏览器的交互操作。

事件流：事件捕获阶段(capture phase)
处于目标阶段(target phase)
事件冒泡阶段(bubbling phase)

事件模型可以分为三种：
原始事件模型（DOM0级）
标准事件模型（DOM2级）

#### typeof and instanceof 区别

typeof与instanceof都是判断数据类型的方法，区别如下：

typeof会返回一个变量的基本类型，instanceof返回的是一个布尔值

instanceof 可以准确地判断复杂引用数据类型，但是不能正确判断基础数据类型

而typeof 也存在弊端，它虽然可以判断基础数据类型（null 除外），但是引用数据类型中，除了function 类型以外，其他的也无法判断

可以看到，上述两种方法都有弊端，并不能满足所有场景的需求

如果需要通用检测数据类型，可以采用Object.prototype.toString，调用该方法，统一返回格式“[object Xxx]”的字符串

#### 事件委托机制

事件委托，会把一个或者一组元素的事件委托到它的父层或者更外层元素上，真正绑定事件的是外层元素，而不是目标元素

当事件响应到目标元素上时，会通过事件冒泡机制从而触发它的外层元素的绑定事件上，然后在外层元素上去执行函数

事件委托的应用场景有列表项动态绑定事件

适合事件委托的事件有：`click，mousedown，mouseup，keydown，keyup，keypress`

从上面应用场景中，我们就可以看到使用事件委托存在两大优点：

1. 减少整个页面所需的内存，提升整体性能
2. 动态绑定，减少重复工作

但是使用事件委托也是存在局限性：

`focus、blur`这些事件没有事件冒泡机制，所以无法进行委托绑定事件

如果把所有事件都用事件代理，可能会出现事件误判，即本不该被触发的事件被绑定上了事件

#### new 操作符做了哪些事

1. 创建一个新的对象obj

2. 将对象与构建函数通过原型链连接起来

3. 将构建函数中的this绑定到新建的对象obj上

4. 根据构建函数返回类型作判断，如果是原始值则被忽略，如果是返回对象，需要正常处理

#### ajax原理和步骤

Ajax的原理简单来说通过`XmlHttpRequest`对象来向服务器发异步请求，从服务器获得数据，然后用JavaScript来操作DOM而更新页面

步骤：
1. 创建 Ajax的核心对象 XMLHttpRequest对象

2. 通过 XMLHttpRequest 对象的 open() 方法与服务端建立连接

3. 构建请求所需的数据内容，并通过XMLHttpRequest 对象的 send() 方法发送给服务器端

4. 通过 XMLHttpRequest 对象提供的 onreadystatechange 事件监听服务器端你的通信状态

5. 接受并处理服务端向客户端响应的数据结果

6. 将处理结果更新到 HTML页面中

#### apply、bind、call区别

##### 共同点：功能一致

```
可以改变函数this指向

语法： 函数.call()、函数.apply()、函数.bind()
```

##### 区别：

```
1. call、apply可以立即执行。bind不会立即执行，因为bind返回的是一个函数需要加入()执行。
2. 参数不同：apply第二个参数是数组。call和bind有多个参数需要挨个写。
```

#### 事件循环机制

1. js是单线程的语言。
2. js代码执行流程：同步执行完==》事件循环
	同步的任务都执行完了，才会执行事件循环的内容
3. 事件循环中包含：【微任务、宏任务】
微任务：promise.then
宏任务：setTimeout..

要执行宏任务的前提是清空了所有的微任务

流程：同步==》事件循环【微任务和宏任务】==》微任务==》宏任务=》微任务...

#### cookie，sessionstorage，localstorage区别

关于cookie、sessionStorage、localStorage三者的区别主要如下：

1. 存储大小：cookie数据大小不能超过4k，sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大

2. 有效时间：localStorage存储持久数据，浏览器关闭后数据不丢失除非主动删除数据； sessionStorage数据在当前浏览器窗口关闭后自动删除；cookie设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭

3. 数据与服务器之间的交互方式，cookie的数据会自动的传递到服务器，服务器端也可以写cookie到客户端； sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存

#### 数字精度丢失问题

1. 原因：计算机存储双精度浮点数需要先把十进制数转换为二进制的科学记数法的形式，然后计算机以自己的规则{符号位+(指数位+指数偏移量的二进制)+小数部分}存储二进制的科学记数法,因为存储时有位数限制（64位），并且某些十进制的浮点数在转换为二进制数时会出现无限循环，会造成二进制的舍入操作(0舍1入)，当再转换为十进制时就造成了计算误差。

解决方法：

- 先转化为整数再运算
- 利用第三方库，如math.js

#### web攻击手段

- XSS
	攻击方式：攻击者将恶意代码植入到提供给其它用户使用的页面中

	方法：在用户输入的过程中，过滤掉用户输入的恶劣代码

- CSRF
	跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求

	预防方法：
	阻止不明外域的访问同源检测，提交时要求附加本域才能获取的信息

- SQL注入

	将恶意的 Sql查询或添加语句插入到应用的输入参数中，再在后台 Sql服务器上解析执行进行的攻击

	预防方法：严格检查输入变量的类型和格式
	过滤和转义特殊字符
	对访问数据库的Web应用程序采用Web应用防火墙
